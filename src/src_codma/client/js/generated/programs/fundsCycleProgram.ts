/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  containsBytes,
  fixEncoderSize,
  getBytesEncoder,
  type Address,
  type ReadonlyUint8Array,
} from 'gill';
import {
  type ParsedAddBeneficiaryInstruction,
  type ParsedClaimCollateralInstruction,
  type ParsedDepositCollateralInstruction,
  type ParsedDepositMonthlyInstruction,
  type ParsedEnableClaimingInstruction,
  type ParsedExitInstruction,
  type ParsedInitializeInstruction,
  type ParsedPunishInstruction,
  type ParsedWithdrawInstruction,
} from '../instructions';

export const FUNDS_CYCLE_PROGRAM_PROGRAM_ADDRESS =
  'BAmKovDnmFfuvXASrEoRa115N3F4QEBCkjUQtRAvkpAj' as Address<'BAmKovDnmFfuvXASrEoRa115N3F4QEBCkjUQtRAvkpAj'>;

export enum FundsCycleProgramAccount {
  BeneficiaryAccount,
  ConfigAccount,
  VaultAccount,
}

export function identifyFundsCycleProgramAccount(
  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): FundsCycleProgramAccount {
  const data = 'data' in account ? account.data : account;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([63, 115, 143, 239, 199, 217, 180, 40])
      ),
      0
    )
  ) {
    return FundsCycleProgramAccount.BeneficiaryAccount;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([189, 255, 97, 70, 186, 189, 24, 102])
      ),
      0
    )
  ) {
    return FundsCycleProgramAccount.ConfigAccount;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([230, 251, 241, 83, 139, 202, 93, 28])
      ),
      0
    )
  ) {
    return FundsCycleProgramAccount.VaultAccount;
  }
  throw new Error(
    'The provided account could not be identified as a fundsCycleProgram account.'
  );
}

export enum FundsCycleProgramInstruction {
  AddBeneficiary,
  ClaimCollateral,
  DepositCollateral,
  DepositMonthly,
  EnableClaiming,
  Exit,
  Initialize,
  Punish,
  Withdraw,
}

export function identifyFundsCycleProgramInstruction(
  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): FundsCycleProgramInstruction {
  const data = 'data' in instruction ? instruction.data : instruction;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([105, 214, 106, 141, 180, 166, 123, 238])
      ),
      0
    )
  ) {
    return FundsCycleProgramInstruction.AddBeneficiary;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([55, 78, 194, 172, 196, 18, 230, 252])
      ),
      0
    )
  ) {
    return FundsCycleProgramInstruction.ClaimCollateral;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([156, 131, 142, 116, 146, 247, 162, 120])
      ),
      0
    )
  ) {
    return FundsCycleProgramInstruction.DepositCollateral;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([252, 123, 80, 64, 66, 80, 61, 199])
      ),
      0
    )
  ) {
    return FundsCycleProgramInstruction.DepositMonthly;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([125, 165, 100, 79, 224, 80, 88, 119])
      ),
      0
    )
  ) {
    return FundsCycleProgramInstruction.EnableClaiming;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([234, 32, 12, 71, 126, 5, 219, 160])
      ),
      0
    )
  ) {
    return FundsCycleProgramInstruction.Exit;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([175, 175, 109, 31, 13, 152, 155, 237])
      ),
      0
    )
  ) {
    return FundsCycleProgramInstruction.Initialize;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([111, 102, 66, 126, 232, 125, 236, 171])
      ),
      0
    )
  ) {
    return FundsCycleProgramInstruction.Punish;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([183, 18, 70, 156, 148, 109, 161, 34])
      ),
      0
    )
  ) {
    return FundsCycleProgramInstruction.Withdraw;
  }
  throw new Error(
    'The provided instruction could not be identified as a fundsCycleProgram instruction.'
  );
}

export type ParsedFundsCycleProgramInstruction<
  TProgram extends string = 'BAmKovDnmFfuvXASrEoRa115N3F4QEBCkjUQtRAvkpAj',
> =
  | ({
      instructionType: FundsCycleProgramInstruction.AddBeneficiary;
    } & ParsedAddBeneficiaryInstruction<TProgram>)
  | ({
      instructionType: FundsCycleProgramInstruction.ClaimCollateral;
    } & ParsedClaimCollateralInstruction<TProgram>)
  | ({
      instructionType: FundsCycleProgramInstruction.DepositCollateral;
    } & ParsedDepositCollateralInstruction<TProgram>)
  | ({
      instructionType: FundsCycleProgramInstruction.DepositMonthly;
    } & ParsedDepositMonthlyInstruction<TProgram>)
  | ({
      instructionType: FundsCycleProgramInstruction.EnableClaiming;
    } & ParsedEnableClaimingInstruction<TProgram>)
  | ({
      instructionType: FundsCycleProgramInstruction.Exit;
    } & ParsedExitInstruction<TProgram>)
  | ({
      instructionType: FundsCycleProgramInstruction.Initialize;
    } & ParsedInitializeInstruction<TProgram>)
  | ({
      instructionType: FundsCycleProgramInstruction.Punish;
    } & ParsedPunishInstruction<TProgram>)
  | ({
      instructionType: FundsCycleProgramInstruction.Withdraw;
    } & ParsedWithdrawInstruction<TProgram>);
